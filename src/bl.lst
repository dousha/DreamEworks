     1                                  ; bootloader
     2                                  ; -f bin
     3                                  ; note that after jumping into stage2
     4                                  ; this code will be covered by stack
     5                                  
     6                                  [bits 16]
     7                                  [org 0x7c00]
     8                                  
     9                                  TOTAL_SECTORS equ 360 ; how many cylinders do we want to read?
    10                                  ; 1 cylinder = 2 x 18 sectors = 2 x 18 x 512 bytes = 18432 bytes
    11                                  
    12                                  _stage1:
    13 00000000 BC007C                  mov sp, 0x7c00 ; stack rasies upwards, 0x500 ~ 0x7bff are free
    14 00000003 31C0                    xor ax, ax
    15 00000005 E80001                  call mem_probe ; get memory info
    16 00000008 EB7B                    jmp load_stage2 ; load stage 2
    17                                  
    18                                  ; --------- sub functions
    19                                  
    20                                  printdot:
    21 0000000A 50                      	push ax
    22 0000000B 31C0                    	xor ax, ax
    23 0000000D B40E                    	mov ah, 0x0e
    24 0000000F B02E                    	mov al, '.'
    25 00000011 CD10                    	int 0x10
    26 00000013 58                      	pop ax
    27 00000014 C3                      	ret
    28                                  
    29                                  printstr: ; si -> str_start
    30 00000015 31C0                    	xor ax, ax
    31 00000017 B40E                    	mov ah, 0x0e
    32 00000019 8A04                    	mov al, [si]
    33 0000001B 3C00                    	cmp al, 0
    34 0000001D 7407                    	je printstr_break
    35 0000001F CD10                    	int 0x10
    36 00000021 83C601                  	add si, 1
    37 00000024 EBEF                    	jmp printstr
    38                                  printstr_break:
    39 00000026 C3                      	ret
    40                                  
    41                                  fstrcmp: ; si -> src, di -> dest
    42 00000027 50                      	push ax
    43 00000028 56                      	push si
    44 00000029 57                      	push di
    45 0000002A 31C0                    	xor ax, ax
    46                                  .cnt:
    47 0000002C 8A04                    	mov al, [si]
    48 0000002E 3C00                    	cmp al, 0
    49 00000030 740C                    	je .done
    50 00000032 3A05                    	cmp al, [di]
    51 00000034 750D                    	jne .noteq
    52 00000036 83C601                  	add si, 1
    53 00000039 83C701                  	add di, 1
    54 0000003C EBEE                    	jmp .cnt
    55                                  .done:
    56 0000003E F9                      	stc
    57 0000003F 5F                      	pop di
    58 00000040 5E                      	pop si
    59 00000041 58                      	pop ax
    60 00000042 C3                      	ret
    61                                  .noteq:
    62 00000043 F8                      	clc
    63 00000044 5F                      	pop di
    64 00000045 5E                      	pop si
    65 00000046 58                      	pop ax
    66 00000047 C3                      	ret
    67                                  
    68                                  read_disk:
    69                                  	; es:bx -> dest
    70                                  	; ax -> sector (0 - 2880)
    71 00000048 50                      	push ax
    72 00000049 51                      	push cx
    73 0000004A 52                      	push dx
    74 0000004B 56                      	push si
    75 0000004C 31F6                    	xor si, si
    76 0000004E 31D2                    	xor dx, dx
    77 00000050 B112                    	mov cl, 18
    78 00000052 F6F1                    	div cl
    79 00000054 88E1                    	mov cl, ah
    80 00000056 80C101                  	add cl, 1
    81 00000059 88C2                    	mov dl, al
    82 0000005B 89D0                    	mov ax, dx ; this flushes ah
    83 0000005D 31D2                    	xor dx, dx
    84 0000005F B202                    	mov dl, 2
    85 00000061 F6F2                    	div dl
    86 00000063 88C5                    	mov ch, al
    87 00000065 31D2                    	xor dx, dx
    88 00000067 88E6                    	mov dh, ah
    89 00000069 B200                    	mov dl, 0
    90                                  .retry:
    91 0000006B B402                    	mov ah, 2
    92 0000006D B001                    	mov al, 1
    93 0000006F 83C601                  	add si, 1
    94 00000072 83FE05                  	cmp si, 5
    95 00000075 0F8DCF00                	jge bad_boot
    96 00000079 CD13                    	int 0x13
    97 0000007B 72EE                    	jc .retry
    98 0000007D E88AFF                  	call printdot
    99 00000080 5E                      	pop si
   100 00000081 5A                      	pop dx
   101 00000082 59                      	pop cx
   102 00000083 58                      	pop ax
   103 00000084 C3                      	ret
   104                                  
   105                                  load_stage2:
   106                                  	; the following code shall load kernel into 0x8000
   107                                  	; load table
   108 00000085 31C0                    	xor ax, ax
   109 00000087 8EC0                    	mov es, ax
   110 00000089 BB0080                  	mov bx, 0x8000
   111 0000008C B80100                  	mov ax, 1
   112 0000008F E8B6FF                  	call read_disk
   113 00000092 BE[5001]                	mov si, table_string
   114 00000095 89DF                    	mov di, bx
   115 00000097 E88DFF                  	call fstrcmp
   116 0000009A 0F83AA00                	jnc bad_boot
   117                                  	; 16 records per sector
   118 0000009E BE[5901]                	mov si, kern_string
   119 000000A1 31C9                    	xor cx, cx
   120                                  .cnt:
   121 000000A3 83C101                  	add cx, 1
   122 000000A6 83F910                  	cmp cx, 16
   123 000000A9 7F0A                    	jg .next_sector
   124 000000AB 83C720                  	add di, 32
   125 000000AE E876FF                  	call fstrcmp
   126 000000B1 7213                    	jc .found
   127 000000B3 EBEE                    	jmp .cnt
   128                                  .next_sector:
   129 000000B5 83C001                  	add ax, 1
   130 000000B8 E88DFF                  	call read_disk ; bx = 0x8000, this would cover them up
   131 000000BB 89DF                    	mov di, bx
   132 000000BD 803D00                  	cmp BYTE [di], 0
   133 000000C0 0F848400                	je bad_boot ; kernel not found
   134 000000C4 EBDD                    	jmp .cnt
   135                                  .found:
   136 000000C6 83C708                  	add di, 8
   137 000000C9 668B05                  	mov DWORD eax, [di]
   138 000000CC 83C704                  	add di, 4
   139 000000CF 668B15                  	mov DWORD edx, [di]
   140 000000D2 6631C9                  	xor ecx, ecx
   141 000000D5 66B900020000            	mov ecx, 512
   142 000000DB 66F7F1                  	div ecx
   143 000000DE 6683FA00                	cmp edx, 0
   144 000000E2 7561                    	jne hang ; ...FIXME
   145 000000E4 BA0008                  	mov dx, 0x800
   146 000000E7 8EC2                    	mov es, dx
   147 000000E9 31DB                    	xor bx, bx
   148 000000EB 83C010                  	add ax, 0x10; edhd bug??
   149 000000EE 89C1                    	mov cx, ax
   150 000000F0 81C16801                	add cx, TOTAL_SECTORS
   151                                  .continue:
   152 000000F4 83C001                  	add ax, 1
   153 000000F7 39C8                    	cmp ax, cx
   154 000000F9 7F0A                    	jg .read_done
   155 000000FB E84AFF                  	call read_disk
   156 000000FE 83C220                  	add dx, 0x20
   157 00000101 8EC2                    	mov es, dx
   158 00000103 EBEF                    	jmp .continue
   159                                  .read_done:
   160 00000105 E9(0080)                	jmp 0x8000 ; kernel loaded in this addr
   161                                  
   162                                  mem_probe:
   163 00000108 6631DB                  	xor ebx, ebx
   164 0000010B 8EC3                    	mov es, bx
   165 0000010D BF007E                  	mov di, 0x7e00 ; right next to the gap between kernel and boot loader
   166                                  mem_probe_loop:
   167 00000110 66B820E80000            	mov eax, 0xe820
   168 00000116 66BA50414D53            	mov edx, 0x534D4150 ; magic number
   169 0000011C 66B914000000            	mov ecx, 20
   170 00000122 CD15                    	int 0x15
   171 00000124 7218                    	jc mem_probe_error
   172 00000126 663D50414D53            	cmp eax, 0x534D4150
   173 0000012C 7510                    	jne mem_probe_error
   174 0000012E 6683FB00                	cmp ebx, 0
   175 00000132 7404                    	je mem_probe_finish
   176 00000134 01CF                    	add di, cx
   177 00000136 EBD8                    	jmp mem_probe_loop
   178                                  mem_probe_finish:
   179 00000138 89F8                    	mov ax, di
   180 0000013A A30010                  	mov word [0x1000], ax
   181 0000013D C3                      	ret
   182                                  mem_probe_error:
   183 0000013E BE[7801]                	mov si, no_mem_probe_msg
   184 00000141 E8D1FE                  	call printstr
   185 00000144 C3                      	ret
   186                                  
   187                                  hang:
   188 00000145 F4                      	hlt
   189 00000146 EBFD                    	jmp hang
   190                                  
   191                                  bad_boot:
   192 00000148 BE[6201]                	mov si, die_msg
   193 0000014B E8C7FE                  	call printstr
   194 0000014E EBF5                    	jmp hang
   195                                  
   196                                  table_string:
   197 00000150 235245435F54424C        	db "#REC_TBL"
   198 00000158 00                      	db 0
   199                                  kern_string:
   200 00000159 6B65726E20202020        	db "kern    "
   201 00000161 00                      	db 0
   202                                  die_msg:
   203 00000162 4641494C4544205245-     	db "FAILED READING DISK"
   203 0000016B 4144494E4720444953-
   203 00000174 4B                 
   204 00000175 0A0D00                  	db 0x0a, 13, 0
   205                                  no_mem_probe_msg:
   206 00000178 43414E4E4F54205052-     	db "CANNOT PROBE MEMORY"
   206 00000181 4F4245204D454D4F52-
   206 0000018A 59                 
   207 0000018B 0A0D00                  	db 0x0a, 13, 0
   208                                  load_done_msg:
   209 0000018E 646F6E65                	db "done"
   210 00000192 0A0D00                  	db 0x0a, 13, 0
   211                                  
   212                                  _stage1_end:
   213 00000195 00<rept>                times 510-($-$$) db 0
   214 000001FE 55AA                    db 0x55, 0xaa
